# -*- coding: utf-8 -*-
"""SciPy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UmZ9SQEtxGLzkMNX5KkRyiuIg2v0_Vdz

Resolu√ß√£o de Equa√ß√£o Diferencial:

Definimos a fun√ß√£o dydt como a derivada de
ùë¶
y em rela√ß√£o a
ùë°
t, representando a equa√ß√£o diferencial
ùë¶
‚Ä≤
=
‚àí
2
ùë¶
y
‚Ä≤
 =‚àí2y.
Utilizamos solve_ivp para resolver a equa√ß√£o diferencial no intervalo de tempo de 0 a 5.
A solu√ß√£o √© plotada usando Matplotlib para visualizar o comportamento de
ùë¶
(
ùë°
)
y(t).
Otimiza√ß√£o de Fun√ß√£o:

Definimos a fun√ß√£o f(x) = (x - 3)^2 + 4 que desejamos minimizar.
Usamos minimize com o m√©todo BFGS, que √© um algoritmo de otimiza√ß√£o eficiente para encontrar o valor m√≠nimo da fun√ß√£o.
A fun√ß√£o imprime o valor m√≠nimo de
ùëì
(
ùë•
)
f(x) e o valor de
ùë•
x onde o m√≠nimo ocorre.
"""

# Primeiro, vamos importar as bibliotecas necess√°rias
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import minimize

# 1. Resolvendo uma Equa√ß√£o Diferencial com SciPy
# Vamos resolver a equa√ß√£o diferencial y' = -2 * y com y(0) = 1

# Definindo a fun√ß√£o que representa a derivada de y em rela√ß√£o a t
def dydt(t, y):
    return -2 * y

# Condi√ß√µes iniciais
y0 = [1]  # Valor inicial de y
t_span = (0, 5)  # Intervalo de tempo

# Resolvendo a equa√ß√£o diferencial
solution = solve_ivp(dydt, t_span, y0, t_eval=np.linspace(0, 5, 100))

# Plotando a solu√ß√£o
plt.plot(solution.t, solution.y[0], label="y(t)")
plt.xlabel("Tempo t")
plt.ylabel("y(t)")
plt.title("Solu√ß√£o da Equa√ß√£o Diferencial y' = -2 * y")
plt.legend()
plt.show()

# 2. Otimizando uma Fun√ß√£o com SciPy
# Agora, vamos encontrar o m√≠nimo da fun√ß√£o f(x) = (x - 3)^2 + 4

# Definindo a fun√ß√£o a ser minimizada
def f(x):
    return (x - 3) ** 2 + 4

# Ponto inicial para o algoritmo de otimiza√ß√£o
x0 = [0]

# Usando o m√©todo 'BFGS' para encontrar o m√≠nimo
result = minimize(f, x0, method='BFGS')

# Exibindo o resultado
print("Valor m√≠nimo de f(x):", result.fun)
print("Valor de x que minimiza f(x):", result.x)

"""Exemplo de Ajuste de Curva e Interpola√ß√£o com SciPy
Neste exemplo, vamos:

Gerar dados simulados e ajust√°-los a uma curva exponencial usando curve_fit da SciPy.
Interpolar os dados usando interp1d para criar uma curva suave entre os pontos.
"""

# Importando bibliotecas necess√°rias
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.interpolate import interp1d

# 1. Ajuste de Curva (Curve Fitting)
# Gerando dados simulados com ru√≠do
np.random.seed(0)
x_data = np.linspace(0, 4, 50)
y_data = 3 * np.exp(-1.5 * x_data) + np.random.normal(0, 0.2, x_data.size)

# Definindo a fun√ß√£o exponencial para ajuste
def exponential_func(x, a, b):
    return a * np.exp(b * x)

# Ajustando a curva aos dados
params, covariance = curve_fit(exponential_func, x_data, y_data, p0=[2, -1])
a_fit, b_fit = params

# Plotando os dados originais e a curva ajustada
plt.scatter(x_data, y_data, label="Dados com Ru√≠do", color="red")
plt.plot(x_data, exponential_func(x_data, a_fit, b_fit), label=f"Curva Ajustada: y = {a_fit:.2f} * exp({b_fit:.2f} * x)", color="blue")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Ajuste de Curva Exponencial")
plt.legend()
plt.show()

# 2. Interpola√ß√£o (Interpolation)
# Selecionando alguns pontos de dados esparsos
x_sparse = np.linspace(0, 4, 10)
y_sparse = 3 * np.exp(-1.5 * x_sparse)

# Criando a fun√ß√£o de interpola√ß√£o
interp_func = interp1d(x_sparse, y_sparse, kind='cubic')

# Gerando pontos interpolados
x_dense = np.linspace(0, 4, 100)
y_dense = interp_func(x_dense)

# Plotando os pontos esparsos e a interpola√ß√£o
plt.scatter(x_sparse, y_sparse, label="Pontos Espalhados", color="green")
plt.plot(x_dense, y_dense, label="Interpola√ß√£o C√∫bica", color="purple")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Interpola√ß√£o C√∫bica")
plt.legend()
plt.show()